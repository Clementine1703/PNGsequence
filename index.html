<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Main</title>
	<style>
		*{
			margin: 0;
			padding: 0;
			box-sizing: border-box;
		}

		body{
			width: 100%;
			min-height: 100vh;
		}

		.preloader{
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			position: fixed;
			width: 100%;
			height: 100vh;
			z-index: 100;
			background-color: white;
		}

		.background{
			position: fixed;
			width: 100%;
			height: 100vh;
		}

		.container{
			width: 100%;
			height: 450vh;
		}
	</style>
</head>
<body>
	<div class="preloader" id="preloader">
		<div><p style="font-size: 30px;">Загрузка...</p></div><br>
		<div>{{ downloadedImages }}/{{ allImages }}</div>
	</div>

	<div class="background">
		<canvas id="bgAnimation" ></canvas>
	</div>

	<div class="container">

	</div>

	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.0.5/vue.min.js"></script>

	
	<script type="text/javascript">

				const countOfImages = 179;
				const imageURL = 'bg_images/babina30fps_jpeg_v3<number_of_image>.jpg';
				const start_animation_stop_kadr = 76;
				let context_scalled = false;
				let preloadImagesCounter = 1;
				let delayOn = false;


		document.addEventListener('DOMContentLoaded', ()=>{

			deletePreloader();

			// фуекция задержки
			function sleep(milliseconds) {
  				const date = Date.now();
  				let currentDate = null;
  				do {
    				currentDate = Date.now();
  				} while (currentDate - date < milliseconds);
}


			// ф-я, которая удаляет preloader
			function deletePreloader(){
				var preloader = document.querySelector(".preloader");
				preloader.parentNode.removeChild(preloader);
			}

			function start_animation(images){
				for (let i = 1; i < images; i++){
					let replace_value = i;
					let replace_value_str = replace_value.toString();
					for (let k = 0; k < countOfImages.toString().length - replace_value.toString().length; k++){
					replace_value_str = '0' + replace_value_str;
					};
					bg.image.src = imageURL.replace('<number_of_image>', replace_value_str);
					console.log(bg.image.src);
					bg.render();
					
					
					
					
				};
			}

			// ф-я предзагрузки всех изображений фона (удаляет preloader после того как все изображения загружены)
			function preload(arrayOfImages) {
    			$(arrayOfImages).each(function(){
				let photo = new Image();
        		photo.src = this;
				photo.onload = ()=>{
					if (preloadImagesCounter < countOfImages){
						preloadImagesCounter++;
						preloader_app?preloader_app.downloadedImages = preloadImagesCounter:null;
					}
					else {
						// deletePreloader();
						start_animation(start_animation_stop_kadr);
						return 0;
					}
					
				}
    			});
			}

			// формирует список с url изображений для их дальнейшей предзагрузки. Работает
			// с константой imageSRC и подставляет вместо заглушки число от 0 до количества изображений
			function createPreloaderList() {
				let preload_list = [];
    			for (let i = 0; i < countOfImages; i++){
					let replace_value = i;
					let replace_value_str = replace_value.toString();
					for (let k = 0; k < countOfImages.toString().length - replace_value.toString().length; k++){
					replace_value_str = '0' + replace_value_str;
					}
					let preload_src = imageURL.replace('<number_of_image>', replace_value_str);
					preload_list.push(preload_src);
				}
				return preload_list;
				
			}


			// ф-я создающая объект для работы с анимацией
			function sprite (options) {
				var that = {};
				that.context = options.context;
				that.width = options.width;
				that.height = options.height;
				that.image = options.image;
				
				// ф-я отрисовывает новое фото фона
				that.render = function () {

				that.context.clearRect(0, 0, canvas.width, canvas.height);

				// Draw the animation
				let scaleW = that.width/window.innerWidth;
				let scaleY = that.height/window.innerHeight;
				that.context.drawImage(
					that.image,
					0,
					0,
					that.width,
					that.height,
					0,
					0,
					that.width/scaleW,
					that.height/scaleY);
				};
				
				return that;
			}

			// ф-я, которая меняет задний фон в зависимости от прокрутки страницы
			function changeImage(){
				let numberOfImage = String(Math.floor(window.scrollY/((document.body.scrollHeight - window.innerHeight)/179)));
				numberOfImage_str = numberOfImage
				for (let i = 0; i < String(countOfImages).length - numberOfImage.length; i++){
					numberOfImage_str = '0' + numberOfImage_str;
				}

				bg.image.src = imageURL.replace('<number_of_image>', numberOfImage_str);
				bg.image.onload = ()=>{
				bg.render();
			}
			}





			preload(createPreloaderList());

			var bgImage = new Image();
			bgImage.src = "bg_images/babina30fps_jpeg_v3000.jpg";
			

			var canvas = document.getElementById("bgAnimation");
			canvas.width = innerWidth;
			canvas.height = innerHeight;

			var bg = sprite({
    		context: canvas.getContext("2d"),
    		width: 1920,
    		height: 1080,
    		image: bgImage
			});


			bg.image.onload = ()=>{
				bg.render();
				
			}

			var exScrollValue = 0;



			window.addEventListener('wheel', ()=>{
				if (exScrollValue != Math.floor(window.scrollY)){
					changeImage();
					exScrollValue = Math.floor(window.scrollY);
				}
			})

			setInterval(()=>{
				if (exScrollValue != Math.floor(window.scrollY)){
					changeImage();
					exScrollValue = Math.floor(window.scrollY);
				}
			}, 50)
		})


		const preloader_app = new Vue({
		  				el: '#preloader',
		  				data: {
			 				downloadedImages: preloadImagesCounter,
			 				allImages: countOfImages,
		  				},
				})

	</script>
</body>
</html>